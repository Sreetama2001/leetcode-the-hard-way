"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[39138],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return m}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=a,d=c["".concat(l,".").concat(m)]||c[m]||u[m]||o;return n?r.createElement(d,i(i({ref:t},h),{},{components:n})):r.createElement(d,i({ref:t},h))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},11028:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return p},default:function(){return f},frontMatter:function(){return l},metadata:function(){return h},toc:function(){return c}});var r,a=n(87462),o=n(63366),i=(n(67294),n(3905)),s=["components"],l={description:"Author: @wingkwong | https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/",tags:["Array","Dynamic Programming","Bit Manipulation","Bitmask"]},p="1434 - Number of Ways to Wear Different Hats to Each Other (Hard)",h={unversionedId:"1400-1499/number-of-ways-to-wear-different-hats-to-each-other-hard",id:"1400-1499/number-of-ways-to-wear-different-hats-to-each-other-hard",title:"1434 - Number of Ways to Wear Different Hats to Each Other (Hard)",description:"Author: @wingkwong | https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/",source:"@site/solutions/1400-1499/1434-number-of-ways-to-wear-different-hats-to-each-other-hard.md",sourceDirName:"1400-1499",slug:"/1400-1499/number-of-ways-to-wear-different-hats-to-each-other-hard",permalink:"/leetcode-the-hard-way/solutions/1400-1499/number-of-ways-to-wear-different-hats-to-each-other-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1400-1499/1434-number-of-ways-to-wear-different-hats-to-each-other-hard.md",tags:[{label:"Array",permalink:"/leetcode-the-hard-way/solutions/tags/array"},{label:"Dynamic Programming",permalink:"/leetcode-the-hard-way/solutions/tags/dynamic-programming"},{label:"Bit Manipulation",permalink:"/leetcode-the-hard-way/solutions/tags/bit-manipulation"},{label:"Bitmask",permalink:"/leetcode-the-hard-way/solutions/tags/bitmask"}],version:"current",sidebarPosition:1434,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/",tags:["Array","Dynamic Programming","Bit Manipulation","Bitmask"]},sidebar:"tutorialSidebar",previous:{title:"1431 - Kids With the Greatest Number of Candies (Easy)",permalink:"/leetcode-the-hard-way/solutions/1400-1499/kids-with-the-greatest-number-of-candies-easy"},next:{title:"1448 - Count Good Nodes in Binary Tree (Medium)",permalink:"/leetcode-the-hard-way/solutions/1400-1499/count-good-nodes-in-binary-tree-medium"}},u={},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming",id:"approach-1-dynamic-programming",level:2}],m=(r="SolutionAuthor",function(e){return console.warn("Component "+r+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)}),d={toc:c};function f(e){var t=e.components,n=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"1434---number-of-ways-to-wear-different-hats-to-each-other-hard"},"1434 - Number of Ways to Wear Different Hats to Each Other (Hard)"),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"There are ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," people and ",(0,i.kt)("inlineCode",{parentName:"p"},"40")," types of hats labeled from ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"40"),"."),(0,i.kt)("p",null,"Given a 2D integer array ",(0,i.kt)("inlineCode",{parentName:"p"},"hats"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"hats[i]")," is a list of all hats preferred by the ",(0,i.kt)("inlineCode",{parentName:"p"},"ith")," person."),(0,i.kt)("p",null,"Return ",(0,i.kt)("em",{parentName:"p"},"the number of ways that the n people wear different hats to each other"),"."),(0,i.kt)("p",null,"Since the answer may be too large, return it modulo ",(0,i.kt)("inlineCode",{parentName:"p"},"109 + 7"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: hats = [[3,4],[4,5],[5]]\nOutput: 1\nExplanation: There is only one way to choose hats given the conditions. \nFirst person choose hat 3, Second person choose hat 4 and last one hat 5.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: hats = [[3,5,1],[3,5]]\nOutput: 4\nExplanation: There are 4 ways to choose hats:\n(3,5), (5,3), (1,3) and (1,5)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 3:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]\nOutput: 24\nExplanation: Each person can choose hats labeled from 1 to 4.\nNumber of Permutations of (1,2,3,4) = 24.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"n == hats.length")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= n <= 10")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= hats[i].length <= 40")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= hats[i][j] <= 40")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hats[i]")," contains a list of ",(0,i.kt)("strong",{parentName:"li"},"unique")," integers.")),(0,i.kt)("h2",{id:"approach-1-dynamic-programming"},"Approach 1: Dynamic Programming"),(0,i.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int n, M = 1e9 + 7;\n    \n    int dfs(vector<vector<int>>& hatsToPeople, vector<vector<int>>& dp, int hat, int mask) {\n        // if the mask is able to reache the end state, \n        // i.e. all people can wear some hats, then return 1\n        if (mask == (1 << n) - 1) return 1;\n        // if the current hat is out of 40, return 0\n        if (hat > 40) return 0;\n        // if we calculated the result before, return it directly\n        if (dp[mask][hat] != -1) return dp[mask][hat];\n        // get number of ways if we skip this hat\n        long res = dfs(hatsToPeople, dp, hat + 1, mask);\n        // since the current hat can be assigned to different people\n        // we try all of them\n        for (auto& person: hatsToPeople[hat]) {\n            // if this person has been assigned with a hat, then skip it\n            if ((1 << person) & mask) continue;\n            // then we can assign this hat to this person\n            (res += dfs(hatsToPeople, dp, hat + 1, mask | (1 << person))) %= M;\n        }\n        // memoize the result\n        return dp[mask][hat] = res;\n    }\n    \n    int numberWays(vector<vector<int>>& hats) {\n        // number of people\n        n = hats.size();\n        // for each hat, we map to different people\n        vector<vector<int>> hatsToPeople(41);\n        // iterate each person\n        for (int i = 0; i < n; i++) {\n            // iterate i-th person's preferred hats\n            for (auto &h : hats[i]) {\n                // assign hat h to person i\n                hatsToPeople[h].push_back(i);\n            }\n        }\n        // init dp\n        vector<vector<int>> dp(1 << n, vector<int>(41, -1));\n        // dfs\n        return dfs(hatsToPeople, dp, 1, 0);\n    }\n};\n")))}f.isMDXComponent=!0}}]);