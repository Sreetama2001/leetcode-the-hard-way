"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[32889],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return h}});var n=a(67294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var i=n.createContext({}),p=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(i.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,i=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=p(a),h=s,u=c["".concat(i,".").concat(h)]||c[h]||d[h]||r;return a?n.createElement(u,l(l({ref:t},m),{},{components:a})):n.createElement(u,l({ref:t},m))}));function h(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,l=new Array(r);l[0]=c;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o.mdxType="string"==typeof e?e:s,l[1]=o;for(var p=2;p<r;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},44579:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return i},default:function(){return w},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return d}});var n=a(87462),s=a(63366),r=(a(67294),a(3905)),l=["components"],o={description:"Author: @wingkwong | https://leetcode.com/problems/palindrome-linked-list/",tags:["Linked List","Two Pointers","Stack","Recursion"]},i="0234 - Palindrome Linked List (Easy)",p={unversionedId:"0200-0299/palindrome-linked-list-easy",id:"0200-0299/palindrome-linked-list-easy",title:"0234 - Palindrome Linked List (Easy)",description:"Author: @wingkwong | https://leetcode.com/problems/palindrome-linked-list/",source:"@site/solutions/0200-0299/0234-palindrome-linked-list-easy.md",sourceDirName:"0200-0299",slug:"/0200-0299/palindrome-linked-list-easy",permalink:"/leetcode-the-hard-way/solutions/0200-0299/palindrome-linked-list-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0200-0299/0234-palindrome-linked-list-easy.md",tags:[{label:"Linked List",permalink:"/leetcode-the-hard-way/solutions/tags/linked-list"},{label:"Two Pointers",permalink:"/leetcode-the-hard-way/solutions/tags/two-pointers"},{label:"Stack",permalink:"/leetcode-the-hard-way/solutions/tags/stack"},{label:"Recursion",permalink:"/leetcode-the-hard-way/solutions/tags/recursion"}],version:"current",sidebarPosition:234,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/palindrome-linked-list/",tags:["Linked List","Two Pointers","Stack","Recursion"]},sidebar:"tutorialSidebar",previous:{title:"0231 - Power of Two (Easy)",permalink:"/leetcode-the-hard-way/solutions/0200-0299/power-of-two-easy"},next:{title:"0242 - Valid Anagram (Easy)",permalink:"/leetcode-the-hard-way/solutions/0200-0299/valid-anagram-easy"}},m={},d=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Fast &amp; Slow Pointers",id:"approach-1-fast--slow-pointers",level:2},{value:"Approach 2: Convert it to String",id:"approach-2-convert-it-to-string",level:2},{value:"Approach 3: Stack",id:"approach-3-stack",level:2},{value:"Approach 4: Follow up: O(n) time, O(1) space",id:"approach-4-follow-up-on-time-o1-space",level:2}],c=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)}},h=c("Tabs"),u=c("TabItem"),k=c("SolutionAuthor"),N={toc:d};function w(e){var t=e.components,a=(0,s.Z)(e,l);return(0,r.kt)("wrapper",(0,n.Z)({},N,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"0234---palindrome-linked-list-easy"},"0234 - Palindrome Linked List (Easy)"),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"Given the ",(0,r.kt)("inlineCode",{parentName:"p"},"head")," of a singly linked list, return ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if it is a palindrome."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: head = [1,2,2,1]\nOutput: true\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: head = [1,2]\nOutput: false\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The number of nodes in the list is in the range ",(0,r.kt)("inlineCode",{parentName:"li"},"[1, 105]"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0 <= Node.val <= 9"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Follow up:")," Could you do it in ",(0,r.kt)("inlineCode",{parentName:"p"},"O(n)")," time and ",(0,r.kt)("inlineCode",{parentName:"p"},"O(1)")," space?"),(0,r.kt)("h2",{id:"approach-1-fast--slow-pointers"},"Approach 1: Fast & Slow Pointers"),(0,r.kt)(h,{mdxType:"Tabs"},(0,r.kt)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(k,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        // find the middle node\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while(fast && fast->next) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        // handle odd case\n        if(fast) slow = slow->next;\n        // reverse the last half of the list\n        ListNode *node = slow;\n        ListNode *last = nullptr;\n        ListNode *next = nullptr;\n        while(node){\n            next = node->next;\n            node->next = last;\n            last = node;\n            node = next;\n        }\n        // compare each half of the list\n        node = last;\n        while(node){\n            if (node->val == head->val) node = node->next, head = head->next;\n            else return false;\n        }\n        return true;\n    }\n};\n")))),(0,r.kt)("h2",{id:"approach-2-convert-it-to-string"},"Approach 2: Convert it to String"),(0,r.kt)(h,{mdxType:"Tabs"},(0,r.kt)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(k,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        // convert it to a string\n        string s;\n        while (head != NULL) {\n            s += head->val;\n            head = head->next;\n        }\n        // test if a string is palindrome\n        string t = s;\n        reverse(t.begin(), t.end());\n        return s == t;\n    }\n};\n")))),(0,r.kt)("h2",{id:"approach-3-stack"},"Approach 3: Stack"),(0,r.kt)("p",null,"Iterative approach using Stack"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Push first half of the elements onto a stack."),(0,r.kt)("li",{parentName:"ul"},"Iterate through the linked list, using fast runner / slow runner technique."),(0,r.kt)("li",{parentName:"ul"},"At each step, push the data from the slow runner onto a stack"),(0,r.kt)("li",{parentName:"ul"},"When the fast runner hits the end of the list, the slow runner will have reached the middle of the list."),(0,r.kt)("li",{parentName:"ul"},"By this point, the stack will have all the elements from the front of the linked list, but in reverse order Last, iterate through the rest of the slow runner node, and compare the node to the top of the stack.")),(0,r.kt)("p",null,"Time Complexity: ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),", where ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"n")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," - # of nodes in the list"),(0,r.kt)("p",null,"Space complexity: ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,r.kt)(h,{mdxType:"Tabs"},(0,r.kt)(u,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)(k,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        // Stack\n        Stack<Integer> stack = new Stack<>();\n        // Fast & Slow runner iteration\n        while (fast != null && fast.next != null) {\n            stack.push(slow.val);\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        // If list has odd number of elements, Skip the middle element\n        if (fast != null) {\n            slow = slow.next;\n        }\n        while (slow != null) {\n            int value = stack.pop().intValue();\n            if (slow.val != value) {\n                return false;\n            }\n            slow = slow.next;\n        }\n        return true;\n    }\n}\n")))),(0,r.kt)("h2",{id:"approach-4-follow-up-on-time-o1-space"},"Approach 4: Follow up: O(n) time, O(1) space"),(0,r.kt)("p",null,"Easy steps to solve the problem,"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Find the middle node"),(0,r.kt)("li",{parentName:"ul"},"Reverse a list from middle"),(0,r.kt)("li",{parentName:"ul"},"Compare both halves"),(0,r.kt)("li",{parentName:"ul"},"Re-reverse the list (optional here), and return true if either of halves are empty")),(0,r.kt)("p",null,"Time Complexity: ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),", where ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"n")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," - # of nodes in the list"),(0,r.kt)("p",null,"Space complexity: ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mn",{parentName:"mrow"},"1"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(1)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord"},"1"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,r.kt)(h,{mdxType:"Tabs"},(0,r.kt)(u,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)(k,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        ListNode mid = middleNode(head);\n        ListNode secondHead = reverseList(mid);\n        // Compare head with reversed middle head\n        while (head != null && secondHead != null) {\n            // if both values are not matching then it's not a palindrome\n            if (head.val != secondHead.val) break;\n            // Keep moving forward\n            head = head.next;\n            secondHead = secondHead.next;\n        }\n        return head == null || secondHead == null;\n    }\n\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public ListNode reverseList(ListNode head) {\n        if (head == null) return null;\n        ListNode prev = null;\n        ListNode current = head;\n        while (current != null) {\n            ListNode next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n        return prev;\n    }\n}\n")))))}w.isMDXComponent=!0}}]);