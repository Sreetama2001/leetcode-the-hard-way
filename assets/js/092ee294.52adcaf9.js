"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[77061],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),s=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(n),m=o,h=c["".concat(u,".").concat(m)]||c[m]||p[m]||a;return n?r.createElement(h,i(i({ref:t},d),{},{components:n})):r.createElement(h,i({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=c;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},83727:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return u},metadata:function(){return d},toc:function(){return c}});var r,o=n(87462),a=n(63366),i=(n(67294),n(3905)),l=["components"],u={description:"Author: @wingkwong | https://leetcode.com/problems/count-good-nodes-in-binary-tree/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},s="1448 - Count Good Nodes in Binary Tree (Medium)",d={unversionedId:"1400-1499/count-good-nodes-in-binary-tree-medium",id:"1400-1499/count-good-nodes-in-binary-tree-medium",title:"1448 - Count Good Nodes in Binary Tree (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/count-good-nodes-in-binary-tree/",source:"@site/solutions/1400-1499/1448-count-good-nodes-in-binary-tree-medium.md",sourceDirName:"1400-1499",slug:"/1400-1499/count-good-nodes-in-binary-tree-medium",permalink:"/leetcode-the-hard-way/solutions/1400-1499/count-good-nodes-in-binary-tree-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1400-1499/1448-count-good-nodes-in-binary-tree-medium.md",tags:[{label:"Tree",permalink:"/leetcode-the-hard-way/solutions/tags/tree"},{label:"Depth-First Search",permalink:"/leetcode-the-hard-way/solutions/tags/depth-first-search"},{label:"Breadth-First Search",permalink:"/leetcode-the-hard-way/solutions/tags/breadth-first-search"},{label:"Binary Tree",permalink:"/leetcode-the-hard-way/solutions/tags/binary-tree"}],version:"current",sidebarPosition:1448,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/count-good-nodes-in-binary-tree/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},sidebar:"tutorialSidebar",previous:{title:"1434 - Number of Ways to Wear Different Hats to Each Other (Hard)",permalink:"/leetcode-the-hard-way/solutions/1400-1499/number-of-ways-to-wear-different-hats-to-each-other-hard"},next:{title:"1457 - Pseudo-Palindromic Paths in a Binary Tree (Medium)",permalink:"/leetcode-the-hard-way/solutions/1400-1499/pseudo-palindromic-paths-in-a-binary-tree-medium"}},p={},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS",id:"approach-1-dfs",level:2}],m=(r="SolutionAuthor",function(e){return console.warn("Component "+r+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)}),h={toc:c};function f(e){var t=e.components,n=(0,a.Z)(e,l);return(0,i.kt)("wrapper",(0,o.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"1448---count-good-nodes-in-binary-tree-medium"},"1448 - Count Good Nodes in Binary Tree (Medium)"),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Given a binary tree ",(0,i.kt)("inlineCode",{parentName:"p"},"root"),", a node ",(0,i.kt)("em",{parentName:"p"},"X")," in the tree is named\xa0",(0,i.kt)("strong",{parentName:"p"},"good")," if in the path from root to ",(0,i.kt)("em",{parentName:"p"},"X")," there are no nodes with a value ",(0,i.kt)("em",{parentName:"p"},"greater than")," X."),(0,i.kt)("p",null,"Return the number of ",(0,i.kt)("strong",{parentName:"p"},"good")," nodes in the binary tree."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: root = [3,1,4,3,null,1,5]\nOutput: 4\nExplanation: Nodes in blue are good.\nRoot Node (3) is always a good node.\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\nNode 5 -> (3,4,5) is the maximum value in the path\nNode 3 -> (3,1,3) is the maximum value in the path.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: root = [3,3,null,4,2]\nOutput: 3\nExplanation: Node 2 -> (3, 3, 2) is not good, because "3" is higher than it.\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 3:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: root = [1]\nOutput: 1\nExplanation: Root is considered as good.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The number of nodes in the binary tree is in the range\xa0",(0,i.kt)("inlineCode",{parentName:"li"},"[1, 10^5]"),"."),(0,i.kt)("li",{parentName:"ul"},"Each node's value is between ",(0,i.kt)("inlineCode",{parentName:"li"},"[-10^4, 10^4]"),".")),(0,i.kt)("h2",{id:"approach-1-dfs"},"Approach 1: DFS"),(0,i.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Time complexity: O(N) as we visit every node only once.\n// Space complexity: O(H) where H is the height of the tree.\n// In the worst case, H would be N given that the tree only has one path.\nclass Solution {\npublic:\n    // the idea is to record the max value from the root to the node\n    // we can first initialise mx as INT_MIN \n    int goodNodes(TreeNode* root, int mx = INT_MIN) {\n        // if the root is null, we return 0\n        if (!root) return 0;\n        // then we can break it into 3 parts\n        // the first part is the current node\n        // if the current node value is greater than the maximum value so far\n        // that means the current node is a good node\n        // hence we add 1, else add 0\n        return (mx <= root->val ? 1 : 0) + \n                // the second part is the result of the left sub-tree\n                // we traverse it with the updated maximum value at the current point\n                // we don't need to check if root->left is null or not here\n                // as we cover the null case in the first line\n                goodNodes(root->left, max(root->val, mx)) + \n                // the last part is the result of the right sub-tree\n                // we traverse it with the updated maximum value at the current point\n                // we don't need to check if root->right is null or not here\n                // as we cover the null case in the first line\n                goodNodes(root->right, max(root->val, mx));\n    }\n};\n")))}f.isMDXComponent=!0}}]);