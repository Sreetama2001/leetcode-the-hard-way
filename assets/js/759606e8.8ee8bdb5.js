"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[44700],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function m(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=m(e,["components","mdxType","originalType","parentName"]),c=s(n),d=a,b=c["".concat(l,".").concat(d)]||c[d]||p[d]||o;return n?r.createElement(b,i(i({ref:t},u),{},{components:n})):r.createElement(b,i({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=c;var m={};for(var l in t)hasOwnProperty.call(t,l)&&(m[l]=t[l]);m.originalType=e,m.mdxType="string"==typeof e?e:a,i[1]=m;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},66469:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return m},metadata:function(){return s},toc:function(){return p}});var r=n(87462),a=n(63366),o=(n(67294),n(3905)),i=["components"],m={description:"Author: @wingkwong | https://leetcode.com/problems/strobogrammatic-number/",tags:["Hash Map"]},l="0246 - Strobogrammatic Number (Easy)",s={unversionedId:"0200-0299/strobogrammatic-number-easy",id:"0200-0299/strobogrammatic-number-easy",title:"0246 - Strobogrammatic Number (Easy)",description:"Author: @wingkwong | https://leetcode.com/problems/strobogrammatic-number/",source:"@site/solutions/0200-0299/0246-strobogrammatic-number-easy.md",sourceDirName:"0200-0299",slug:"/0200-0299/strobogrammatic-number-easy",permalink:"/leetcode-the-hard-way/solutions/0200-0299/strobogrammatic-number-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0200-0299/0246-strobogrammatic-number-easy.md",tags:[{label:"Hash Map",permalink:"/leetcode-the-hard-way/solutions/tags/hash-map"}],version:"current",sidebarPosition:246,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/strobogrammatic-number/",tags:["Hash Map"]},sidebar:"tutorialSidebar",previous:{title:"0242 - Valid Anagram (Easy)",permalink:"/leetcode-the-hard-way/solutions/0200-0299/valid-anagram-easy"},next:{title:"0258 - Add Digits (Easy)",permalink:"/leetcode-the-hard-way/solutions/0200-0299/add-digits-easy"}},u={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Two Pointers",id:"approach-1-two-pointers",level:2}],c={toc:p};function d(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"0246---strobogrammatic-number-easy"},"0246 - Strobogrammatic Number (Easy)"),(0,o.kt)("p",null,"Given a string ",(0,o.kt)("inlineCode",{parentName:"p"},"num")," which represents an integer, return ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," ",(0,o.kt)("em",{parentName:"p"},"if")," ",(0,o.kt)("inlineCode",{parentName:"p"},"num")," ",(0,o.kt)("em",{parentName:"p"},"is a ",(0,o.kt)("strong",{parentName:"em"},"strobogrammatic number")),"."),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"strobogrammatic number")," is a number that looks the same when rotated ",(0,o.kt)("inlineCode",{parentName:"p"},"180")," degrees (looked at upside down)."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("pre",null,(0,o.kt)("code",null,'Input: num = "69"',(0,o.kt)("strong",null,"Output:")," true")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",null,'Input: num = "88"',(0,o.kt)("strong",null,"Output:")," true")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 3:")),(0,o.kt)("pre",null,(0,o.kt)("code",null,'Input: num = "962"',(0,o.kt)("strong",null,"Output:")," false")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= num.length <= 50")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"num")," consists of only digits."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"num")," does not contain any leading zeros except for zero itself.")),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/strobogrammatic-number/"},"https://leetcode.com/problems/strobogrammatic-number/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"First we need to find out which numbers are still valid after rotated by 180 degrees. There are only three cases. First it becomes an invalid number, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"2"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"3"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"4")," and etc. The second case is the number remains the same, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"8"),". The third case is it becomes another number, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"6 -> 9"),". "),(0,o.kt)("p",null,"Therefore, we can use two pointers from the left and right to check if the number can be rotatable. If so, would the rotated number be the same as the target number."),(0,o.kt)("h2",{id:"approach-1-two-pointers"},"Approach 1: Two Pointers"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool isStrobogrammatic(string num) {\n        // m[0] = 0\n        // m[1] = 1\n        // m[2] = -1\n        // m[3] = -1\n        // m[4] = -1\n        // m[5] = -1\n        // m[6] = 9\n        // m[7] = -1\n        // m[8] = 8\n        // m[9] = 6\n        vector<int> m = {0, 1, -1, -1, -1, -1, 9, -1, 8, 6};\n        int n = num.size();\n        // each time we check two characters (num[0], num[n - 1 - 1]), (num[1], num[n - i - 2]), ... and so on\n        // it could be same character if the length of num is odd, i.e. num[n / 2]\n        for (int i = 0; i < n + 1 / 2; i++) {\n            if (m[num[i] - '0'] != num[n - 1 - i] - '0') {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n")))}d.isMDXComponent=!0}}]);