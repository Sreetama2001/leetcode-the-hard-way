"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[67547],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var m=a.createContext({}),s=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(m.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,m=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=s(n),d=r,h=c["".concat(m,".").concat(d)]||c[d]||p[d]||i;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},99648:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return m},default:function(){return v},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return p}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),l=["components"],o={description:"Author: @ganajayant | https://leetcode.com/problems/time-based-key-value-store/"},m="0981 - Time Based Key-Value Store (Medium)",s={unversionedId:"0900-0999/time-based-key-value-store-medium",id:"0900-0999/time-based-key-value-store-medium",title:"0981 - Time Based Key-Value Store (Medium)",description:"Author: @ganajayant | https://leetcode.com/problems/time-based-key-value-store/",source:"@site/solutions/0900-0999/0981-time-based-key-value-store-medium.md",sourceDirName:"0900-0999",slug:"/0900-0999/time-based-key-value-store-medium",permalink:"/leetcode-the-hard-way/solutions/0900-0999/time-based-key-value-store-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0981-time-based-key-value-store-medium.md",tags:[],version:"current",sidebarPosition:981,frontMatter:{description:"Author: @ganajayant | https://leetcode.com/problems/time-based-key-value-store/"},sidebar:"tutorialSidebar",previous:{title:"0976 - Largest Perimeter Triangle (Easy)",permalink:"/leetcode-the-hard-way/solutions/0900-0999/largest-perimeter-triangle-easy"},next:{title:"0985 - Sum of Even Numbers After Queries (Medium)",permalink:"/leetcode-the-hard-way/solutions/0900-0999/sum-of-even-numbers-after-queries.medium"}},u={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Binary Search",id:"approach-1-binary-search",level:2}],c=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)}},d=c("Tabs"),h=c("TabItem"),y=c("SolutionAuthor"),f={toc:p};function v(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0981---time-based-key-value-store-medium"},"0981 - Time Based Key-Value Store (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/time-based-key-value-store/"},"https://leetcode.com/problems/time-based-key-value-store/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp."),(0,i.kt)("p",null,"Implement the TimeMap class:"),(0,i.kt)("p",null,"TimeMap() Initializes the object of the data structure.\nvoid set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp."),(0,i.kt)("p",null,'String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns "".'),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: ["TimeMap", "set", "get", "get", "set", "get", "get"] \n        [[], ["foo", "bar", 1], ["foo", 1], ["foo", 3], ["foo", "bar2", 4], ["foo", 4], ["foo", 5]]\nOutput: [null, null, "bar", "bar", null, "bar2", "bar2"]\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= key.length, value.length <= 100")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key and value consist of lowercase English letters and digits.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= timestamp <= 107")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"All the timestamps timestamp of set are strictly increasing.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"At most 2 * 105 calls will be made to set and get."))),(0,i.kt)("h2",{id:"approach-1-binary-search"},"Approach 1: Binary Search"),(0,i.kt)("p",null,"create a hashmap to store key value pair,here the value timestamp value with acutal value which is stored in another Object of class Element\nWhenever get used for a particular element we will be going to get all the values of corresponding key and binary search the list of timestamps "),(0,i.kt)(d,{mdxType:"Tabs"},(0,i.kt)(h,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(y,{name:"@ganajayant",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Element {\n    String val;\n    int timestamp;\n\n    public Element(String val, int timestamp) {\n        this.val = val;\n        this.timestamp = timestamp;\n    }\n\n}\n\nclass TimeMap {\n    HashMap<String, LinkedList<Element>> hm;\n\n    public TimeMap() {\n        hm = new HashMap<>();\n    }\n\n    public void set(String key, String value, int timestamp) {\n        if (hm.containsKey(key)) {\n            LinkedList<Element> ll = hm.get(key);\n            ll.add(new Element(value, timestamp));\n            hm.put(key, ll);\n        } else {\n            LinkedList<Element> ll = new LinkedList<>();\n            ll.add(new Element(value, timestamp));\n            hm.put(key, ll);\n        }\n    }\n\n    public String get(String key, int timestamp) {\n        LinkedList<Element> ll = hm.getOrDefault(key, null);\n        if (ll == null) {\n            return "";\n        }\n        int low = 0, high = ll.size() - 1;\n        if (ll.get(low).timestamp > timestamp) {\n            return "";\n        }\n        if (ll.get(high).timestamp <= timestamp) {\n            return ll.get(high).val;\n        }\n        while (low < high) {\n            int mid = (low + high) / 2;\n            if (ll.get(mid).timestamp == timestamp) {\n                return ll.get(mid).val;\n            }\n            if (ll.get(mid).timestamp < timestamp) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n\n        }\n        return ll.get(low - 1).val;\n    }\n}\n')))))}v.isMDXComponent=!0}}]);