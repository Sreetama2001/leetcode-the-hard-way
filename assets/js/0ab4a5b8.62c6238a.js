"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[10135],{3905:function(t,e,n){n.d(e,{Zo:function(){return c},kt:function(){return m}});var r=n(67294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function a(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function l(t,e){if(null==t)return{};var n,r,o=function(t,e){if(null==t)return{};var n,r,o={},i=Object.keys(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var p=r.createContext({}),s=function(t){var e=r.useContext(p),n=e;return t&&(n="function"==typeof t?t(e):a(a({},e),t)),n},c=function(t){var e=s(t.components);return r.createElement(p.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(t,e){var n=t.components,o=t.mdxType,i=t.originalType,p=t.parentName,c=l(t,["components","mdxType","originalType","parentName"]),d=s(n),m=o,f=d["".concat(p,".").concat(m)]||d[m]||u[m]||i;return n?r.createElement(f,a(a({ref:e},c),{},{components:n})):r.createElement(f,a({ref:e},c))}));function m(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var i=n.length,a=new Array(i);a[0]=d;var l={};for(var p in e)hasOwnProperty.call(e,p)&&(l[p]=e[p]);l.originalType=t,l.mdxType="string"==typeof t?t:o,a[1]=l;for(var s=2;s<i;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},47743:function(t,e,n){n.r(e),n.d(e,{assets:function(){return c},contentTitle:function(){return p},default:function(){return m},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return u}});var r=n(87462),o=n(63366),i=(n(67294),n(3905)),a=["components"],l={title:"Graph Theory",description:"Graph Templates",hide_table_of_contents:!1,keywords:["leetcode","template","graph","algorithm","bellman ford","dijkstra","topological sort"]},p=void 0,s={unversionedId:"graph-theory",id:"graph-theory",title:"Graph Theory",description:"Graph Templates",source:"@site/templates/graph-theory.md",sourceDirName:".",slug:"/graph-theory",permalink:"/leetcode-the-hard-way/templates/graph-theory",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/templates/graph-theory.md",tags:[],version:"current",frontMatter:{title:"Graph Theory",description:"Graph Templates",hide_table_of_contents:!1,keywords:["leetcode","template","graph","algorithm","bellman ford","dijkstra","topological sort"]},sidebar:"tutorialSidebar",previous:{title:"Bit Manipulation",permalink:"/leetcode-the-hard-way/templates/bit-manipulation"},next:{title:"Ordered Set and GNU C++ PBDS",permalink:"/leetcode-the-hard-way/templates/ordered-set"}},c={},u=[{value:"Bellman Ford Algorithm",id:"bellman-ford-algorithm",level:3},{value:"Dijkstra",id:"dijkstra",level:3},{value:"Topological Sorting",id:"topological-sorting",level:3},{value:"Disjoin Set Union (DSU)",id:"disjoin-set-union-dsu",level:3}],d={toc:u};function m(t){var e=t.components,n=(0,o.Z)(t,a);return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"bellman-ford-algorithm"},"Bellman Ford Algorithm"),(0,i.kt)("p",null,"Go to ",(0,i.kt)("a",{parentName:"p",href:"../tutorials/graph-theory/bellman-ford-algorithm"},"Tutorial")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T_a3, typename T_vector>\nvoid bellman_ford(T_a3 &g, T_vector &dist, int src, int mx_edges) {\n    dist[src] = 0;\n    for (int i = 0; i <= mx_edges; i++) {\n        T_vector ndist = dist;\n        for (auto x : g) {\n            auto [from, to, cost] = x;\n            ndist[to] = min(ndist[to], dist[from] + cost);\n        }\n        dist = ndist;\n    }\n}\n")),(0,i.kt)("h3",{id:"dijkstra"},"Dijkstra"),(0,i.kt)("p",null,"Go to ",(0,i.kt)("a",{parentName:"p",href:"../tutorials/graph-theory/dijkstra"},"Tutorial")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T_pair, typename T_vector>\nvoid dijkstra(T_pair &g, T_vector &dist, int start) {\n  priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n  dist[start] = 0;\n  pq.push({start, 0});\n  while (!pq.empty()) {\n    auto [u_node, u_cost] = pq.top(); pq.pop();\n    if (u_cost > dist[u_node]) continue;\n    for (auto [v_node, v_cost] : g[u_node]) {\n      if (dist[v_node] > dist[u_node] + v_cost) {\n        dist[v_node] = dist[u_node] + v_cost;\n        pq.push({v_node, dist[v_node]});\n      }\n    }\n  }\n}\n")),(0,i.kt)("h3",{id:"topological-sorting"},"Topological Sorting"),(0,i.kt)("p",null,"Go to ",(0,i.kt)("a",{parentName:"p",href:"../tutorials/graph-theory/topological-sorting"},"Tutorial")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"struct TopologicalSort {\n    int n;\n    vector<int> indegree;\n    vector<int> orders;\n    vector<vector<int>> G;\n    bool isTopologicalSorted = false;\n    \n    TopologicalSort(vector<vector<int>>& g, vector<int>& in) {\n        G = g; vector<vector<int>>\n        n = (int) G.size();\n        indegree = in;\n        \n        int res = 0;\n        queue<int> q;\n        for(int i = 0; i < n; i++) {\n            if(indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        while(!q.empty()) {\n            auto u = q.front(); q.pop();\n            orders.push_back(u);\n            for(auto v : G[u]) {\n                if(--indegree[v] == 0) {\n                    q.push(v);\n                }\n            }\n            res++;\n        }\n        isTopologicalSorted = res == n;\n    }\n};\n")),(0,i.kt)("h3",{id:"disjoin-set-union-dsu"},"Disjoin Set Union (DSU)"),(0,i.kt)("p",null,"Go to ",(0,i.kt)("a",{parentName:"p",href:"../tutorials/graph-theory/disjoint-set-union"},"Tutorial")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class dsu {\n public:\n  vector<int> root, rank;\n  int n;\n  int cnt;\n\n  dsu(int _n) : n(_n) {\n    root.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; i++) {\n        root[i] = i;\n        rank[i] = 1;\n    }\n    cnt = n;\n  }\n\n  inline int getCount() { return cnt; }\n\n  inline int get(int x) { return (x == root[x] ? x : (root[x] = get(root[x]))); }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n        if (rank[x] > rank[y]) {\n            root[y] = x;\n        } else if (rank[x] < rank[y]) {\n            root[x] = y;\n        } else {\n            root[y] = x;\n            rank[x] += 1;\n        }\n        cnt--;\n      return true;\n    }\n    return false;\n  }\n};\n")))}m.isMDXComponent=!0}}]);