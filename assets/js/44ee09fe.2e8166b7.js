"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[98707],{3905:function(e,n,t){t.d(n,{Zo:function(){return s},kt:function(){return p}});var o=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var m=o.createContext({}),d=function(e){var n=o.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},s=function(e){var n=d(e.components);return o.createElement(m.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,m=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),u=d(t),p=i,h=u["".concat(m,".").concat(p)]||u[p]||c[p]||a;return t?o.createElement(h,r(r({ref:n},s),{},{components:t})):o.createElement(h,r({ref:n},s))}));function p(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,r=new Array(a);r[0]=u;var l={};for(var m in n)hasOwnProperty.call(n,m)&&(l[m]=n[m]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var d=2;d<a;d++)r[d]=t[d];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},89305:function(e,n,t){t.r(n),t.d(n,{assets:function(){return s},contentTitle:function(){return m},default:function(){return f},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return c}});var o=t(87462),i=t(63366),a=(t(67294),t(3905)),r=["components"],l={description:"Author: @wingkwong | https://leetcode.com/problems/minimum-time-to-make-rope-colorful/",tags:["Array","String","Dynamic Programming","Greedy"]},m="1578 - Minimum Time to Make Rope Colorful (Medium)",d={unversionedId:"1500-1599/minimum-time-to-make-rope-colorful-medium",id:"1500-1599/minimum-time-to-make-rope-colorful-medium",title:"1578 - Minimum Time to Make Rope Colorful (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/minimum-time-to-make-rope-colorful/",source:"@site/solutions/1500-1599/1578-minimum-time-to-make-rope-colorful-medium.md",sourceDirName:"1500-1599",slug:"/1500-1599/minimum-time-to-make-rope-colorful-medium",permalink:"/leetcode-the-hard-way/solutions/1500-1599/minimum-time-to-make-rope-colorful-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1500-1599/1578-minimum-time-to-make-rope-colorful-medium.md",tags:[{label:"Array",permalink:"/leetcode-the-hard-way/solutions/tags/array"},{label:"String",permalink:"/leetcode-the-hard-way/solutions/tags/string"},{label:"Dynamic Programming",permalink:"/leetcode-the-hard-way/solutions/tags/dynamic-programming"},{label:"Greedy",permalink:"/leetcode-the-hard-way/solutions/tags/greedy"}],version:"current",sidebarPosition:1578,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/minimum-time-to-make-rope-colorful/",tags:["Array","String","Dynamic Programming","Greedy"]},sidebar:"tutorialSidebar",previous:{title:"1575 - Count All Possible Routes (Hard)",permalink:"/leetcode-the-hard-way/solutions/1500-1599/count-all-possible-routes-hard"},next:{title:"1584 - Min Cost to Connect All Points (Medium)",permalink:"/leetcode-the-hard-way/solutions/1500-1599/min-cost-to-connect-all-points-medium"}},s={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Greedy",id:"approach-1-greedy",level:2}],u=function(e){return function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)}},p=u("Tabs"),h=u("TabItem"),b=u("SolutionAuthor"),T={toc:c};function f(e){var n=e.components,t=(0,i.Z)(e,r);return(0,a.kt)("wrapper",(0,o.Z)({},T,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"1578---minimum-time-to-make-rope-colorful-medium"},"1578 - Minimum Time to Make Rope Colorful (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/minimum-time-to-make-rope-colorful/"},"https://leetcode.com/problems/minimum-time-to-make-rope-colorful/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Alice has ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," balloons arranged on a rope. You are given a ",(0,a.kt)("strong",{parentName:"p"},"0-indexed")," string ",(0,a.kt)("inlineCode",{parentName:"p"},"colors")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"colors[i]")," is the color of the ",(0,a.kt)("inlineCode",{parentName:"p"},"ith")," balloon."),(0,a.kt)("p",null,"Alice wants the rope to be ",(0,a.kt)("strong",{parentName:"p"},"colorful"),". She does not want ",(0,a.kt)("strong",{parentName:"p"},"two consecutive balloons")," to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it ",(0,a.kt)("strong",{parentName:"p"},"colorful"),". You are given a ",(0,a.kt)("strong",{parentName:"p"},"0-indexed")," integer array ",(0,a.kt)("inlineCode",{parentName:"p"},"neededTime")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"neededTime[i]")," is the time (in seconds) that Bob needs to remove the ",(0,a.kt)("inlineCode",{parentName:"p"},"ith")," balloon from the rope."),(0,a.kt)("p",null,"Return *the ",(0,a.kt)("strong",{parentName:"p"},"minimum time")," Bob needs to make the rope ",(0,a.kt)("strong",{parentName:"p"},"colorful*"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: colors = \"abaac\", neededTime = [1,2,3,4,5]\nOutput: 3\nExplanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.\nBob can remove the blue balloon at index 2. This takes 3 seconds.\nThere are no longer two consecutive balloons of the same color. Total time = 3.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input: colors = "abc", neededTime = [1,2,3]\nOutput: 0\nExplanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input: colors = "aabaa", neededTime = [1,2,3,4,1]\nOutput: 2\nExplanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.\nThere are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"n == colors.length == neededTime.length")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= n <= 10^5")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= neededTime[i] <= 10^4")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"colors")," contains only lowercase English letters.")),(0,a.kt)("h2",{id:"approach-1-greedy"},"Approach 1: Greedy"),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(b,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Time Complexity: O(n)\n// Space Complexity: O(1)\nclass Solution {\npublic:\n    // intuition: \n    // ---------------\n    // if there are consecutive balloons with the same color, \n    // we want to keep the one with maximum neededTime and remove others \n    \n    // if there are 2 balloons with different colors, ans = 0 as it is colorful\n    // if there are 2 balloons with same color, ans = min(neededTime[0], neededTime[1])\n    // if there are 3 consecutive balloons with same color, ans = sum(neededTime[0 .. 2]) - max(neededTime[0 .. 2])\n    // if there are N consecutive balloons with same color, ans = sum(neededTime[0 .. n - 1]) - max(neededTime[0 .. n - 1])\n    // we don\'t need to calculate the sum and subtract the max though. instead, we can either\n    // 1. update neededTime in place to the max of neededTime[i] and neededTime[i - 1] (shown in below solution) or \n    // 2. store the current max time in a variable\n    // why? let\'s say colors = "aaa" and neededTime = [1,2,1]\n    // we first compare neededTime[0] and neededTime[1] and decide to remove the first balloon (neededTime[0] < neededTime[1])\n    // now colors = "_aa" and neededTime = [_,2,1] and the current max time is 2\n    // then compare neededTime[1] and neededTime[2] and decide to remove the last balloon, (neededTime[2] < neededTime[1])\n    // now colors = "_a_" and neededTime = [_,2,_]. we remove all balloons but the one with maximum neededTime\n    int minCost(string colors, vector<int>& neededTime) {\n        int ans = 0, n = colors.size();\n        for (int i = 1; i < n; i++) {\n            // if the i-th balloon has the same color as (i - 1)th one\n            // e.g. aba[a]c and i = 3 (0-based)\n            if (colors[i] == colors[i - 1]) {\n                // then we remove the one with less time\n                // e.g. in above example, we remove the balloon at index 2 \n                // with neededTime[2] since neededTime[2] < neededTime[3] \n                ans += min(neededTime[i], neededTime[i - 1]);\n                // update the max neededTime inplace \n                // or alternatively you can store it in a variable\n                neededTime[i] = max(neededTime[i], neededTime[i - 1]);\n            }\n        }\n        return ans;\n    }\n};\n'))),(0,a.kt)(h,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)(b,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},'# Time Complexity: O(n)\n# Space Complexity: O(1)\nclass Solution:\n    # intuition: \n    # ---------------\n    # if there are consecutive balloons with the same color, \n    # we want to keep the one with maximum neededTime and remove others \n    \n    # if there are 2 balloons with different colors, ans = 0 as it is colorful\n    # if there are 2 balloons with same color, ans = min(neededTime[0], neededTime[1])\n    # if there are 3 consecutive balloons with same color, ans = sum(neededTime[0 .. 2]) - max(neededTime[0 .. 2])\n    # if there are N consecutive balloons with same color, ans = sum(neededTime[0 .. n - 1]) - max(neededTime[0 .. n - 1])\n    # we don\'t need to calculate the sum and subtract the max though. instead, we can either\n    # 1. update neededTime in place to the max of neededTime[i] and neededTime[i - 1] (shown in below solution) or \n    # 2. store the current max time in a variable\n    # why? let\'s say colors = "aaa" and neededTime = [1,2,1]\n    # we first compare neededTime[0] and neededTime[1] and decide to remove the first balloon (neededTime[0] < neededTime[1])\n    # now colors = "_aa" and neededTime = [_,2,1] and the current max time is 2\n    # then compare neededTime[1] and neededTime[2] and decide to remove the last balloon, (neededTime[2] < neededTime[1])\n    # now colors = "_a_" and neededTime = [_,2,_]. we remove all balloons but the one with maximum neededTime\n    def minCost(self, colors: str, neededTime: List[int]) -> int:\n        ans = 0\n        for i in range(1, len(colors)):\n            # if the i-th balloon has the same color as (i - 1)th one\n            # e.g. aba[a]c and i = 3 (0-based)\n            if colors[i] == colors[i - 1]:\n                # then we remove the one with less time\n                # e.g. in above example, we remove the balloon at index 2 \n                # with neededTime[2] since neededTime[2] < neededTime[3] \n                ans += min(neededTime[i], neededTime[i - 1])\n                # update the max neededTime inplace \n                # or alternatively you can store it in a variable\n                neededTime[i] = max(neededTime[i], neededTime[i - 1])\n        return ans\n'))),(0,a.kt)(h,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)(b,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'// Time Complexity: O(n)\n// Space Complexity: O(1)\nclass Solution {\n    // intuition: \n    // ---------------\n    // if there are consecutive balloons with the same color, \n    // we want to keep the one with maximum neededTime and remove others \n    \n    // if there are 2 balloons with different colors, ans = 0 as it is colorful\n    // if there are 2 balloons with same color, ans = min(neededTime[0], neededTime[1])\n    // if there are 3 consecutive balloons with same color, ans = sum(neededTime[0 .. 2]) - max(neededTime[0 .. 2])\n    // if there are N consecutive balloons with same color, ans = sum(neededTime[0 .. n - 1]) - max(neededTime[0 .. n - 1])\n    // we don\'t need to calculate the sum and subtract the max though. instead, we can either\n    // 1. update neededTime in place to the max of neededTime[i] and neededTime[i - 1] (shown in below solution) or \n    // 2. store the current max time in a variable\n    // why? let\'s say colors = "aaa" and neededTime = [1,2,1]\n    // we first compare neededTime[0] and neededTime[1] and decide to remove the first balloon (neededTime[0] < neededTime[1])\n    // now colors = "_aa" and neededTime = [_,2,1] and the current max time is 2\n    // then compare neededTime[1] and neededTime[2] and decide to remove the last balloon, (neededTime[2] < neededTime[1])\n    // now colors = "_a_" and neededTime = [_,2,_]. we remove all balloons but the one with maximum neededTime\n    public int minCost(String colors, int[] neededTime) {\n        int ans = 0, n = colors.length();\n        for (int i = 1; i < n; i++) {\n            // if the i-th balloon has the same color as (i - 1)th one\n            // e.g. aba[a]c and i = 3 (0-based)\n            if (colors.charAt(i) == colors.charAt(i - 1)) {\n                // then we remove the one with less time\n                // e.g. in above example, we remove the balloon at index 2 \n                // with neededTime[2] since neededTime[2] < neededTime[3] \n                ans += Math.min(neededTime[i], neededTime[i - 1]);\n                // update the max neededTime inplace \n                // or alternatively you can store it in a variable\n                neededTime[i] = Math.max(neededTime[i], neededTime[i - 1]);\n            }\n        }\n        return ans;\n    }\n}\n')))))}f.isMDXComponent=!0}}]);