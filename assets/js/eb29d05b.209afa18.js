"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[64110],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var i=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=u(n),h=o,f=m["".concat(l,".").concat(h)]||m[h]||c[h]||a;return n?i.createElement(f,r(r({ref:t},p),{},{components:n})):i.createElement(f,r({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var u=2;u<a;u++)r[u]=n[u];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},41557:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return w},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return c}});var i=n(87462),o=n(63366),a=(n(67294),n(3905)),r=["components"],s={description:"Author: @wingkwong | https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/",tags:["Math","Bit Manipulation","Simulation"]},l="1680 - Concatenation of Consecutive Binary Numbers (Medium)",u={unversionedId:"1600-1699/concatenation-of-consecutive-binary-numbers-medium",id:"1600-1699/concatenation-of-consecutive-binary-numbers-medium",title:"1680 - Concatenation of Consecutive Binary Numbers (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/",source:"@site/solutions/1600-1699/1680-concatenation-of-consecutive-binary-numbers-medium.md",sourceDirName:"1600-1699",slug:"/1600-1699/concatenation-of-consecutive-binary-numbers-medium",permalink:"/leetcode-the-hard-way/solutions/1600-1699/concatenation-of-consecutive-binary-numbers-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1600-1699/1680-concatenation-of-consecutive-binary-numbers-medium.md",tags:[{label:"Math",permalink:"/leetcode-the-hard-way/solutions/tags/math"},{label:"Bit Manipulation",permalink:"/leetcode-the-hard-way/solutions/tags/bit-manipulation"},{label:"Simulation",permalink:"/leetcode-the-hard-way/solutions/tags/simulation"}],version:"current",sidebarPosition:1680,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/",tags:["Math","Bit Manipulation","Simulation"]},sidebar:"tutorialSidebar",previous:{title:"1679 - Max Number of K-Sum Pairs (Medium)",permalink:"/leetcode-the-hard-way/solutions/1600-1699/max-number-of-k-sum-pairs-medium"},next:{title:"1692 - Count Ways to Distribute Candies (Hard)",permalink:"/leetcode-the-hard-way/solutions/1600-1699/count-ways-to-distribute-candies-hard"}},p={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Bit Manipulation",id:"approach-1-bit-manipulation",level:2}],m=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)}},h=m("Tabs"),f=m("TabItem"),d=m("SolutionAuthor"),b={toc:c};function w(e){var t=e.components,n=(0,o.Z)(e,r);return(0,a.kt)("wrapper",(0,i.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"1680---concatenation-of-consecutive-binary-numbers-medium"},"1680 - Concatenation of Consecutive Binary Numbers (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/"},"https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given an integer ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),", return ",(0,a.kt)("em",{parentName:"p"},"the ",(0,a.kt)("strong",{parentName:"em"},"decimal value")," of the binary string formed by concatenating the binary representations of"),(0,a.kt)("inlineCode",{parentName:"p"},"1"),(0,a.kt)("em",{parentName:"p"},"to"),(0,a.kt)("inlineCode",{parentName:"p"},"n"),"*in order, ",(0,a.kt)("strong",{parentName:"p"},"modulo*"),(0,a.kt)("inlineCode",{parentName:"p"},"109 + 7"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input: n = 1\nOutput: 1\nExplanation: "1" in binary corresponds to the decimal value 1.\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input: n = 3\nOutput: 27\nExplanation: In binary, 1, 2, and 3 corresponds to "1", "10", and "11".\nAfter concatenating them, we have "11011", which corresponds to the decimal value 27.\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input: n = 12\nOutput: 505379714\nExplanation: The concatenation results in "1101110010111011110001001101010111100".\nThe decimal value of that is 118505380540.\nAfter modulo 109 + 7, the result is 505379714.\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= n <= 10^5"))),(0,a.kt)("h2",{id:"approach-1-bit-manipulation"},"Approach 1: Bit Manipulation"),(0,a.kt)(h,{mdxType:"Tabs"},(0,a.kt)(f,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Time Complexity: O(N)\n// Space Complexity: O(1)\nclass Solution {\npublic:\n    // the idea is to use bit manipulation to set the current number based on the previous number\n    // for example, \n    // n = 1, ans = 0b1\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n    // so now we can see a pattern here\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\n    int concatenatedBinary(int n) {\n        // `l` is the bit length to be shifted\n        int M = 1e9 + 7, l = 0;\n        // use long here as it potentially could overflow for int\n        long ans = 0;\n        for (int i = 1; i <= n; i++) {\n            // i & (i - 1) means removing the rightmost set bit\n            // e.g. 100100 -> 100000\n            //      000001 -> 000000\n            //      000000 -> 000000\n            // after removal, if it is 0, then it means it is power of 2\n            // as all power of 2 only contains 1 set bit\n            // if it is power of 2, we increase the bit length `l`\n            if ((i & (i - 1)) == 0) l += 1;\n            // (ans << l) means shifting the orginal answer `l` bits to th left\n            // (x | i) means  using OR operation to set the bit\n            // e.g. 0001 << 3 = 0001000\n            // e.g. 0001000 | 0001111 = 0001111\n            ans = ((ans << l) | i) % M;\n        }\n        return ans;\n    }\n};\n"))),(0,a.kt)(f,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"# Time Complexity: O(N)\n# Space Complexity: O(1)\nclass Solution:\n    # the idea is to use bit manipulation to set the current number based on the previous number\n    # for example, \n    # n = 1, ans = 0b1\n    # n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n    # i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n    # n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \n    # i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n    # n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n    # i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n    # so now we can see a pattern here\n    # we need to shift `l` bits of the previous ans to the left and add the current `i` \n    # how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\n    def concatenatedBinary(self, n: int) -> int:\n        M = 10 ** 9 + 7\n        # `l` is the bit length to be shifted\n        l, ans = 0, 0\n        for i in range(1, n + 1):\n            # i & (i - 1) means removing the rightmost set bit\n            # e.g. 100100 -> 100000\n            #      000001 -> 000000\n            #      000000 -> 000000\n            # after removal, if it is 0, then it means it is power of 2\n            # as all power of 2 only contains 1 set bit\n            # if it is power of 2, we increase the bit length `l`\n            if i & (i - 1) == 0:\n                l += 1\n            # (ans << l) means shifting the orginal answer `l` bits to th left\n            # (x | i) means  using OR operation to set the bit\n            # e.g. 0001 << 3 = 0001000\n            # e.g. 0001000 | 0001111 = 0001111\n            ans = ((ans << l) | i) % M\n        return ans\n"))),(0,a.kt)(f,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"// Time Complexity: O(N)\n// Space Complexity: O(1)\nclass Solution {\n    // the idea is to use bit manipulation to set the current number based on the previous number\n    // for example, \n    // n = 1, ans = 0b1\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n    // so now we can see a pattern here\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\n    public int concatenatedBinary(int n) {\n        // `l` is the bit length to be shifted\n        int M = 1000000007, l = 0;\n        // use long here as it potentially could overflow for int\n        long ans = 0;\n        for (int i = 1; i <= n; i++) {\n            // i & (i - 1) means removing the rightmost set bit\n            // e.g. 100100 -> 100000\n            //      000001 -> 000000\n            //      000000 -> 000000\n            // after removal, if it is 0, then it means it is power of 2\n            // as all power of 2 only contains 1 set bit\n            // if it is power of 2, we increase the bit length `l`\n            if ((i & (i - 1)) == 0) l += 1;\n            // (ans << l) means shifting the orginal answer `l` bits to th left\n            // (x | i) means  using OR operation to set the bit\n            // e.g. 0001 << 3 = 0001000\n            // e.g. 0001000 | 0001111 = 0001111\n            ans = ((ans << l) | i) % M;\n        }\n        return (int) ans;\n    }\n}\n"))),(0,a.kt)(f,{value:"go",label:"Go",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// Time Complexity: O(N)\n// Space Complexity: O(1)\n\n// the idea is to use bit manipulation to set the current number based on the previous number\n// for example, \n// n = 1, ans = 0b1\n// n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\n// i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\n// n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \n// i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\n// n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\n// i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\n// so now we can see a pattern here\n// we need to shift `l` bits of the previous ans to the left and add the current `i` \n// how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\nfunc concatenatedBinary(n int) int {\n    // `l` is the bit length to be shifted\n    ans, l, M := 0, 0, 1_000_000_007\n    for i := 1; i <= n; i++ {\n        // i & (i - 1) means removing the rightmost set bit\n        // e.g. 100100 -> 100000\n        //      000001 -> 000000\n        //      000000 -> 000000\n        // after removal, if it is 0, then it means it is power of 2\n        // as all power of 2 only contains 1 set bit\n        // if it is power of 2, we increase the bit length `l`\n        if (i & (i - 1) == 0) {\n            l += 1\n        }\n        // (ans << l) means shifting the orginal answer `l` bits to th left\n        // (x | i) means  using OR operation to set the bit\n        // e.g. 0001 << 3 = 0001000\n        // e.g. 0001000 | 0001111 = 0001111\n        ans = ((ans << l) | i) % M\n    }   \n    return ans\n}\n\n")))))}w.isMDXComponent=!0}}]);